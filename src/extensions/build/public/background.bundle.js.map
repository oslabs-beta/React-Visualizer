{"version":3,"file":"background.bundle.js","mappings":";;AAAA;AACA;AACA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://react-visualizer/webpack/bootstrap","webpack://react-visualizer/webpack/runtime/make namespace object","webpack://react-visualizer/./src/extensions/background.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable */\n// @ts-nocheck\n\nconst extensions = 'https://developer.chrome.com/docs/extensions';\nconst webstore = 'https://developer.chrome.com/docs/webstore';\n//creating a context menu\nchrome.runtime.onInstalled.addListener(async () => {\n  chrome.contextMenus.create({\n    title: 'C-React',\n    id: 'cReactContextMenu',\n    contexts: ['selection'],\n  });\n});\n\n//opening up a new window when the cReact is selected\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n  if (info.menuItemId == 'cReactContextMenu') {\n    chrome.windows.create({\n      url: 'panel.html',\n    });\n  }\n});\n\n//\nvar openCount = 0;\nchrome.runtime.onConnect.addListener(function (port) {\n  if (port.name == 'devtools-page') {\n    openCount++;\n    port.onDisconnect.addListener(function (port) {\n      openCount--;\n    });\n  }\n});\n\nlet connections = {};\n\nchrome.runtime.onConnect.addListener(function (devToolsConnection) {\n  // assign the listener function to a variable so we can remove it later\n  if (devToolsConnection.name == 'devtools-page') {\n    var devToolsListener = function (message, sender, sendResponse) {\n      // Inject a content script into the identified tab\n      connections[message.tabId] = devToolsConnection;\n      //expecting tabId and file:scriptToInject\n      console.log(connections[message.tabId]);\n      chrome.scripting\n        .executeScript({\n          //target tab\n          target: { tabId: message.tabId },\n          //inject the content script to above tab\n          files: [message.scriptToInject],\n        })\n        .then(() => console.log('script injected'));\n    };\n\n    // add the listener to the one time message - postMessage\n    devToolsConnection.onMessage.addListener(devToolsListener);\n\n    // when we are disconnected, we remove the listener\n    devToolsConnection.onDisconnect.addListener(function () {\n      devToolsConnection.onMessage.removeListener(devToolsListener);\n      var tabs = Object.keys(connections);\n      for (var i = 0, len = tabs.length; i < len; i++) {\n        if (connections[tabs[i]] == devToolsConnection) {\n          //delete the connection tab\n          delete connections[tabs[i]];\n          break;\n        }\n      }\n    });\n  }\n});\n\n//4/10\n// remove the connection for a tab when the tab is closed\nchrome.tabs.onRemoved.addListener(function (tabId, removeInfo) {\n  if (tabId in connections) {\n    delete connections[tabId];\n  }\n});\n//end 4 10\n\n// Message listener for content script\n// chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) {\n//   //new 4/11\n//   if (request.action === 'getTree') {\n//     sendResponse({ tree: trees[request.tabId] });\n//   }\n//   //new 4/11\n//   // Messages from content scripts should have sender.tab set\n//   if (sender.tab) {\n//     console.log(sender.tab.id);\n//     var tabId = sender.tab.id;\n//     if (tabId in connections) {\n//       connections[tabId].postMessage(request);\n//     } else {\n//       console.log('Tab not found in connection list.');\n//     }\n//   } else {\n//     console.log('sender.tab not defined.');\n//   }\n//   return true;\n// });\n\n// chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {\n//   var currentTabId = tabs[0].id;\n//   console.log('Current tab ID in background query:', currentTabId);\n// });\n\nlet treeOfTrees = {};\n\n//\nasync function getCurrentTab() {\n  let queryOptions = { active: true, lastFocusedWindow: true };\n  // `tab` will either be a `tabs.Tab` instance or `undefined`.\n  let [tab] = await chrome.tabs.query(queryOptions);\n  return tab;\n}\nconst tab = getCurrentTab();\nconsole.log('logging tab from background using query ' + tab);\n//testing\nchrome.tabs.onActivated.addListener((activeInfo) => {\n  let selectedTabId = activeInfo.tabId;\n  chrome.runtime.onMessage.addListener((message) => {\n    // Get the tree object from the message\n    if (message.tree) {\n      // console.log('selected TabId ' + selectedTabId);\n      treeOfTrees[selectedTabId] = message.tree;\n      console.log('this is treeOfTrees');\n      console.log(treeOfTrees);\n      chrome.runtime.sendMessage({ fromBGtree1: treeOfTrees });\n      // chrome.runtime.sendMessage({ simp: message.tree });\n    }\n    if (message.nestedObject) {\n      // Do something with the tree object\n      treeOfTrees[selectedTabId] = message.nestedObject;\n      chrome.runtime.sendMessage({ fromBGtree2: treeOfTrees });\n    }\n    if (message.storedVitals) {\n      // Do something with the tree object\n      console.log('storing vitals');\n      // chrome.runtime.sendMessage({ storedVitals: message.storedVitals });\n    }\n  });\n});\n\n// const port = chrome.runtime.connect({ name: 'knockknock' });\n// port.postMessage({ joke: 'Knock knock' });\n// console.log(port.name);\n// port.onMessage.addListener(function (msg) {\n//   console.log('msg in content.js', msg);\n//   if (msg.question === \"Who's there?\")\n//     port.postMessage({ treeData: treeOfTrees });\n//   else if (msg.question === 'Madame who?')\n//     port.postMessage({ answer: 'Madame... Bovary' });\n// });\n"],"names":[],"sourceRoot":""}