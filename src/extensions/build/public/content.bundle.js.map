{"version":3,"file":"content.bundle.js","mappings":";;AAAA;AACA;AACA;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://react-visualizer/webpack/bootstrap","webpack://react-visualizer/webpack/runtime/make namespace object","webpack://react-visualizer/./src/extensions/contentScript.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable */\n// @ts-nocheck\n\n// console.log(document.querySelector(':root'));\n// console.log(document.documentElement);\n// console.log(document.getElementsByTagName('html'));\n\n// const treeFilter = {\n//   acceptNode(node) {\n//     return;\n//     node.tagName == 'META' ||\n//     node.tagName == 'SCRIPT' ||\n//     node.tagName == 'LINK' ||\n//     node.tagName == 'STYLE' ||\n//     node.parentNode.tagName == 'svg'\n//       ? NodeFilter.FILTER_REJECT\n//       : NodeFilter.FILTER_ACCEPT;\n//   },\n// };\n\n// const walkerFilter = {\n//   acceptNode(node) {\n//     return node.nodeName.toLowerCase() !== 'script'\n//       ? NodeFilter.FILTER_ACCEPT\n//       : NodeFilter.FILTER_REJECT;\n//   },\n// };\n\n// // // let walker = document.createTreeWalker(\n// // //   root,\n// // //   NodeFilter.SHOW_ELEMENT,\n// // //   walkerFilter\n// // // );\n\n// let nodeObj = {};\n\n// const grabTree = new MutationObserver(() => {\n//   nodeObj = {};\n//   nodeObj = grabTreeFromBrowser();\n//   chrome.runtime.sendMessage({ nestedObject: nodeObj });\n// });\n\n// const grabTreeFromBrowser = () => {\n//   const root = document.body;\n//   // const root = document.querySelector(':root');\n//   // const root = document.getElementById(':root');\n\n//   const tree = document.createTreeWalker(\n//     root,\n//     NodeFilter.SHOW_ELEMENT,\n//     walkerFilter,\n//     false\n//   );\n//   //create tree walker\n//   const node = tree.currentNode;\n//   const levels = [];\n//   //BFS\n//   //add nodes to build tree\n//   const queue = [{ domNode: node, context: nodeObj, level: 1 }];\n//   while (queue.length > 0) {\n//     //context aka pointer to layer of object\n//     const { domNode, context, level } = queue.shift();\n//     console.log(level);\n//     // context.innerHTML = domNode.innerHTML;\n//     // if current level is greater than levels.length, push node in level. otherwise, create a new level in zero-indexed treeLevels arr\n//     if (level > levels.length) {\n//       levels.push(['']);\n//     } else {\n//       levels[level - 1].push('');\n//     }\n//     // const height = level;\n//     // const width = levels[level - 1].length;\n//     if (!context.attributes) context.attributes = {};\n//     if (!context.name) context.name = '';\n//     if (domNode.nodeName) context.name = domNode.nodeName;\n//     if (\n//       domNode.nodeName === '#text' &&\n//       domNode.textContent !== null &&\n//       domNode.textContent !== undefined\n//     ) {\n//       context.attributes.content = domNode.textContent;\n//     }\n//     //check if current node has children\n//     if (domNode.childNodes !== null && domNode.childNodes.length > 0) {\n//       for (let i = 0; i < domNode.childNodes.length; i++) {\n//         context.children\n//           ? context.children.push({})\n//           : (context.children = [{}]);\n//         queue.push({\n//           domNode: domNode.childNodes[i],\n//           context: context.children[i],\n//           level: level + 1,\n//         });\n//       }\n//     }\n//   }\n//   console.log(nodeObj);\n//   return nodeObj;\n// };\n\n// const observerConfig = {\n//   attributes: true,\n//   childList: true,\n//   subtree: true,\n// };\n\n// grabTree.observe(document.documentElement, observerConfig);\n// grabTreeFromBrowser();\n\n// const treeData4 = JSON.stringify(nodeObj);\n\n// const port = chrome.runtime.connect({ name: 'knockknock' });\n// port.postMessage({ joke: 'Knock knock' });\n// console.log(port.name);\n// port.onMessage.addListener(function (msg) {\n//   console.log(msg);\n//   if (msg.question === \"Who's there?\")\n//     port.postMessage({ treeData: treeData4 });\n//   else if (msg.question === 'Madame who?')\n//     port.postMessage({ answer: 'Madame... Bovary' });\n// });\n\n//Pengbo's new code\n/**\n * @param {DOM node}\n * @return {treeWalker}\n */\n\nconst createWalker = (node) =>\n  document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, walkerFilter);\n\nconst walkerFilter = {\n  acceptNode(node) {\n    if (\n      node.nodeName.toLowerCase() === 'script' ||\n      node.nodeName.toLowerCase() === 'noscript' ||\n      node.nodeName.toLowerCase() === 'link' ||\n      node.nodeName.toLowerCase() === 'style' ||\n      node.nodeName.toLowerCase() === 'img' ||\n      node.nodeName.toLowerCase() === 'iframe' ||\n      node.nodeName.toLowerCase() === 'text' ||\n      node.nodeName.toLowerCase() === 'tspan' ||\n      node.tagName.toLowerCase() == 'svg'\n    )\n      return NodeFilter.FILTER_REJECT;\n    else return NodeFilter.FILTER_ACCEPT;\n  },\n};\n\n/**\n * Take properties of a DOM node and convert them to attributes for D3Node\n * @param {DOM node} DOM node\n * @return an object representing the attributes for D3Node.\n */\n//TODO: decide what attributes to add to d3Node\n\nfunction getAttributes(node) {\n  return { type: node.className || node.nodeName };\n}\n\n/**\n * Get and return the children nodes of the node corresponding to a tree walker\n * @param {treeWalker} walker\n * @return an array of D3nodes that are children of the node corresponding to the walker\n */\nfunction getChildren(walker) {\n  let d3Children = []; //declare an array of d3nodes\n  let childNode = walker.firstChild();\n\n  //find all children of walker.currentNode\n  while (childNode) {\n    //convert walker to D3node\n    let D3Node = createD3Node(walker);\n    let childWalker = createWalker(walker.currentNode);\n    //if the child node has children, recursively call the getChildren and assign the children to d3Node\n    if (childNode.children.length > 0)\n      D3Node.children = getChildren(childWalker);\n    //add the newly created D3Node to the children array\n    d3Children.push(D3Node);\n    //walker move to the next sibling and reassign the childNode to the sibiling node\n    childNode = walker.nextSibling();\n  }\n\n  return d3Children;\n}\n\n/** Convert a walker to a D3 tree Node\n * @param {treeWalker} walker\n * @return {} node for D3 tree\n */\nfunction createD3Node(walker) {\n  //get the node corresponding to the walker object\n  const node = walker.currentNode;\n  //initialize and a new D3Node that will be returned later\n  let D3Node = {};\n  D3Node.name = node.nodeName;\n  D3Node.attributes = getAttributes(node);\n  return D3Node;\n}\n\n/** Traverse the DOM with the initial tree walker\n * @param {treeWalker} walker\n * @returns {} the root node of d3 Tree\n */\nfunction traverse(walker) {\n  let d3Node = createD3Node(walker);\n  if (walker.currentNode.children.length > 0)\n    d3Node.children = getChildren(walker);\n  return d3Node;\n}\n\n// const root = document.getElementById(':root');\n// const root = document.querySelector(':root');\nconst root = document.body;\n\nlet walker = document.createTreeWalker(\n  root,\n  NodeFilter.SHOW_ELEMENT,\n  walkerFilter\n);\n\nlet d3Tree = traverse(walker);\nconst treeData4 = JSON.stringify(d3Tree);\n\nconsole.log('D3 tree is converted:', d3Tree);\n\n//added this michelle\nconst grabTree = new MutationObserver(() => {\n  d3Tree = {};\n  d3Tree = traverse(walker);\n  chrome.runtime.sendMessage({ nestedObject: d3Tree });\n  return d3Tree;\n});\nconst observerConfig = {\n  attributes: true,\n  childList: true,\n  subtree: true,\n};\n\ngrabTree.observe(document.documentElement, observerConfig);\n// //michelle added this michelle\n\nconst port = chrome.runtime.connect({ name: 'knockknock' });\nport.postMessage({ joke: 'Knock knock' });\nconsole.log(port.name);\nport.onMessage.addListener(function (msg) {\n  console.log(msg);\n  if (msg.question === \"Who's there?\")\n    port.postMessage({ treeData: treeData4 });\n  else if (msg.question === 'Madame who?')\n    port.postMessage({ answer: 'Madame... Bovary' });\n});\n"],"names":[],"sourceRoot":""}